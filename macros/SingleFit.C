#include "TH1.h"
#include "TH2.h"
#include "TFile.h"
#include "TTree.h"
#include "TCanvas.h"
#include "TLorentzVector.h"
#include "TClonesArray.h"
#include "TChain.h"
#include "Math/Minimizer.h"
#include "Math/Factory.h"
#include "Math/Functor.h"
#include <iostream>
#include <fstream>
#include <TMath.h>
#include <TF1.h>
#include <TMinuit.h>
#include <TSystem.h>

using namespace std;

Double_t GausOnBase(Double_t *, Double_t *);
void parFromHuman(Double_t beamMeV = 1600.0, Double_t edgeMeV = 500.0, Double_t spreadMeV = 0.0,// Double_t spreadMeV = 30.0, 
		  Double_t colliDist_m = 2.5, Double_t colliRad_mm = 3, Int_t nVec = 2, Double_t *par=NULL);
void enhFromParams(Double_t *par=NULL);
Double_t efit(const Double_t *);
void CheckPol( TH1F* enhHist, TH1F* polHist,  TH1F* enhFit);

TF1 *gausFit;

//Some enumerators and names
enum {
  THETA,  // [0] theta      main angle responsible for coherent edge cutoffs
  SIGMA,  // [1] sigma      smearing of theta
  THETAR, // [2] thetar     relative angle resonsible for colli cutoffs
  SIGMAR, // [3] sigmar     smearing of colli cutoff angle
  //  POWER,
  E0MEV,  // [4] beam energy
  NVEC,   // [5] nvec       no of vectors contributing
  IVEC};  // [6] ivec[]     array of intensities of vectors up to nvec.

//Approx Form factor is F(g^2) = (q^2 + b^(-2)) ^ -2
//Where b= 111 x Z^(-1/3) (x 925 to get into units of crystal lattice)
const Double_t B = 0.247892436;  //where did I get that ? Timm ?
const Double_t A=0.03;           //made up for now, need to get the actual no for this later
const Double_t k=26.5601;        //put in formula for k later (my own stonehenge paper)

//Double_t beamMeV = 1508.0;
// Double_t beamMeV = 1.508;
// Double_t edgeGuess = 0.500;

Double_t beamMeV = 1600.0;
Double_t edgeGuess = 500.0;
//Double_t colliDist_m = 0.0001;
//Double_t colliRad_mm = 10;
Double_t colliDist_m = 2.5;
Double_t colliRad_mm = 3;
// Double_t colliDist_m = 0.1;
// Double_t colliRad_mm = 1.5;
Int_t nVec=3;

const Int_t VECTORS[]={2,4,6,8,10};    //list of the vectors to be included (022,044);

Int_t THETASTEPS = 201;          //no of steps in convoluting with gaussian
Double_t LOWFIT = 308.0;         //how far below the peak in MeV to start fitting

Double_t fitMinEnergy;
Int_t fitMinBin;
Double_t fitMaxEnergy;
Int_t fitMaxBin;
Int_t verbose=0;
Double_t bestPar[11];
Double_t bestChisq;

Int_t counter = 1;
 
//these are really just convenient arrays - they don't ever get plotted.
TH1F *weightHist  = NULL;
TH2F *thetaWeight = NULL;
TH2F *thetaPol    = NULL;
TH2F *thetaTtot   = NULL;
TH2F *thetaItot   = NULL;

//All histograms and related are globals
TH1F *histP   = NULL;  //pol
TH1F *histE   = NULL;  //enh from calculation

TH1F *histD = NULL;  //enh from data to be fitted

TCanvas *genCanvas=NULL;

const Double_t *Errors;
Double_t lowError;
Double_t highError;

//fit of a gaussian on a baseline, for gausFit,
Double_t GausOnBase(Double_t *x, Double_t *par) {
  Double_t arg = 0;
  if (par[2] != 0) arg = (x[0] - par[1])/par[2];
   Double_t fitval = par[3] + par[0]*TMath::Exp(-0.5*arg*arg);
   return fitval;
}

void SingleFit( ){

  //Open input files
//   TString inputFile  = "/w/work14/simong/PolOut/All-Enh-NEW.root";
//   TString outputFile = "/w/work14/simong/PolOut/PolarisationFiles/" + TString::Itoa(fileNumber,10) + "Pol.root";
//   TString inputFile  = "/scratch/simong/All-Enh-NEWEST.root"+TString::Itoa(fileNumber,10);
//   TString outputFile = "/scratch/simong/" + TString::Itoa(fileNumber,10) + "Pol.root";
  TString inputFile  = "/home/simong/Generators/GlueXCB/macros/outPlotsTemp0.root";
  TString outputFile = "/home/simong/Generators/GlueXCB/macros/outPol0.root";

  TFile*  iFile      = new TFile(inputFile,"read"    );
  TFile*  oFile      = new TFile(outputFile,  "recreate");
  
  TH1F*   hCoh;
  TH1F*   hInCoh;
  TH1F*   hPolar;
  hCoh   = (TH1F*)iFile->Get("polhist");
  hInCoh = (TH1F*)iFile->Get("amohist");
  hPolar = (TH1F*)iFile->Get("polhistpol");
  hPolar->Scale(-1);
  
  hCoh->Divide(hInCoh);

  TH1F* hEnh = new TH1F("Enh","Enh",374,100,1600);
  TH1F* hCalcPol = new TH1F("CalcPol","CalcPol",374,100,1600);

  Int_t n=0;

  //Double_t scale = 15;
  Double_t scale = 7.2;

  for(Int_t i = 0; i < hEnh->GetNbinsX(); i++){
    Double_t content  = hCoh->GetBinContent(i);
    Double_t content2 = hPolar->GetBinContent(i);
    if(content==0) continue;
    
    hEnh->SetBinContent(n,hCoh->GetBinContent(i)*scale);
    hEnh->SetBinError(n,hCoh->GetBinError(i)*scale);
    //hEnh->SetBinContent(n,hCoh->GetBinContent(i)*14.3);
    hCalcPol->SetBinContent(n,hPolar->GetBinContent(i));
    hCalcPol->SetBinError(n,hPolar->GetBinError(i));
    n++;
  }
  


  TH1F*    hFileEGpol     = (TH1F*)hEnh->Clone("EGpol");
  hFileEGpol->Reset(); 
  TH1F*    hFileEGfit     = (TH1F*)hEnh->Clone("EGfit");
  hFileEGfit->Reset(); 

  cout << "Run CheckPol" << endl;
  CheckPol(hEnh, hFileEGpol, hFileEGfit);

  hFileEGpol->Write();
  hCoh->Write();
  hEnh->Write();
  hFileEGfit->Write();
  histP->Write();
  hCalcPol->Write();
 
 
  iFile->Close();
  oFile->Close();

}

//------------------------------------------------------------------------------

void CheckPol( TH1F* enhHist, TH1F* polHist, TH1F* enhFit){

  TH1F*    hFileEGenhs = (TH1F*)enhHist->Clone("FileEGenhs");
  histD    = (TH1F*)enhHist->Clone("projX2");
  histD->Reset();

  UInt_t nBins = hFileEGenhs->GetNbinsX();
  Double_t diff1, diff2, lowmean, highmean1, highmean2,fitedge,scalefac,scale;
  Double_t par[11];
  ROOT::Math::Minimizer* min;
  Char_t name[30];

  fitedge = 0;

  gausFit=new TF1("gausFit",GausOnBase,0,100,4);
  genCanvas = new TCanvas("genCanvas","genCanvas",50,50,800,1000);
  genCanvas->Divide(1,2);   
  genCanvas->GetPad(1)->SetGridx(1);
  genCanvas->GetPad(1)->SetGridy(1);
  genCanvas->GetPad(2)->SetGridx(1);
  genCanvas->GetPad(2)->SetGridy(1);

  //Get polarisation
  
  cout << "Remove Spikes" << endl;

  //  Get rid of spikes up and down
  for(UInt_t n=2;n<=nBins-1;n++){
    diff1=(hFileEGenhs->GetBinContent(n)-hFileEGenhs->GetBinContent(n-1))/hFileEGenhs->GetBinContent(n-1);
    diff2=(hFileEGenhs->GetBinContent(n)-hFileEGenhs->GetBinContent(n+1))/hFileEGenhs->GetBinContent(n+1);
    
    if (((fabs(diff1)>0.4)&&(fabs(diff2)>0.4))&&(fabs(diff1-diff2)<0.4)){
      hFileEGenhs->SetBinContent(n,0.5*(hFileEGenhs->GetBinContent(n-1)+hFileEGenhs->GetBinContent(n+1)));
      hFileEGenhs->SetBinError(n,0.5*(hFileEGenhs->GetBinError(n-1)+hFileEGenhs->GetBinError(n+1)));
    }
  }

  
  histD->Add(hFileEGenhs);

//   histD->Write();
//   return;
  
//   for(Int_t i=0;i<histD->GetNbinsX();i++){

//     histD->SetBinContent(i,1+(histD->GetBinContent(i)-1)*(histD->GetBinCenter(i)/beamMeV));

//   }

  histD->GetXaxis()->SetRange(70,110);
  histD->SetMaximum(1.2*histD->GetMaximum());
  histD->SetMinimum(0.0);
  histD->GetXaxis()->SetRange();
  
  histE = (TH1F*)histD->Clone("histE");
  histE->Sumw2(0);
  histE->Reset();
  histE->GetXaxis()->SetRange(70,110);
  histE->SetMaximum(1.2*histD->GetMaximum());
  histE->SetMinimum(0.0);
  histE->GetXaxis()->SetRange();
  histP = (TH1F*)histD->Clone("histP");
  histP->Reset();
  histP->SetMaximum(1);

  // histD->Write();
//   histE->Write();
//   histP->Write();
//   return;

  //Fit
  //Now try to make some guesses at the initial parameters
  histD->GetXaxis()->SetRange(70,110);
  
  Int_t maxBin2 = histD->GetMaximumBin();
  

  histD->GetXaxis()->SetRange(70,110);
  gausFit->SetRange(histD->GetBinCenter(histD->GetMaximumBin()),histD->GetBinCenter(histD->GetMaximumBin())+50.0);
  gausFit->SetParameter(1,histD->GetBinCenter(histD->GetMaximumBin()));
  gausFit->SetParameter(2,10.0);
  gausFit->SetParameter(3,1.0);
  histD->Fit(gausFit,"rN");
  
  lowmean=0.0;
  
  Int_t maxBin = histD->GetMaximumBin();

  
  //Get the edge from the derivative
  for(Float_t d = histD->GetBinCenter(maxBin);d < histD->GetBinCenter(maxBin+90.0);d+=0.1){ 
    if(gausFit->Derivative(d)<lowmean){
      lowmean=gausFit->Derivative(d);
      fitedge=d;
      cout << "EDGEFIT " << fitedge << endl;
    }
  }
  
  histD->GetXaxis()->SetRange(70,110);
  
  //cout << abs(fitedge-edgeGuess) << endl;

  if(abs(fitedge-edgeGuess)>50) return;
  
  //Now we have enough information to set the basic parameters
  //parFromHuman(beamMeV,edgeGuess,0.1,colliDist_m,colliRad_mm,nVec,par);
  //parFromHuman(beamMeV,fitedge,gausFit->GetParameter(2)*2,colliDist_m,colliRad_mm,nVec,par); //orig
  parFromHuman(beamMeV,fitedge,gausFit->GetParameter(2),colliDist_m,colliRad_mm,nVec,par);
  
  //set the intensities
  for(int v=0;v<par[NVEC];v++){                                               //give the vectors intensities
    par[IVEC+v] = histD->GetBinContent(maxBin)*2.0/((Double_t)VECTORS[v]*(Double_t)VECTORS[v]);      //tailing off as 1/VECTORS[v]^2
  }
  
  //cout << "HIIII" << endl;

  if(histD->GetEntries()==0) return;

  enhFromParams(par);
  
  //Redo the intensities according to a the calc / data ration
  scalefac=histD->GetMaximum()/histE->GetMaximum();
  for(int v=0;v<par[NVEC];v++){                                               //give the vectors intensities
    par[IVEC+v]*=scalefac;
  }
  
  histE->GetXaxis()->SetRange(20,200);
  histD->GetXaxis()->SetRange(20,200);
  histP->GetXaxis()->SetRange(20,200);
  //     histE->GetXaxis()->SetRange();
  //     histD->GetXaxis()->SetRange();
  enhFromParams(par);
  
  //Set the range of the fit to be some sensible amount below peak and just past the 2nd peak.
//   fitMinBin=histE->FindBin(histD->GetBinCenter(histD->GetMaximumBin())-LOWFIT);
//   fitMaxBin    = histE->FindBin(par[E0MEV]/(((2.0/4.25)*((par[E0MEV]/histD->GetBinCenter(histD->GetMaximumBin()))-1.0))+1));
  fitMinBin = 12;
  fitMaxBin = 258;
  
  histE->GetXaxis()->SetRange(fitMinBin,fitMaxBin);
  histD->GetXaxis()->SetRange(fitMinBin,fitMaxBin);
  histP->GetXaxis()->SetRange(fitMinBin,fitMaxBin);

    cout << fitMinBin << " " << fitMaxBin << endl;
  
  min = ROOT::Math::Factory::CreateMinimizer("Minuit2", "Simple");
  
  // set tolerance , etc...
  min->SetMaxFunctionCalls(1000000); // for Minuit/Minuit2 
  min->SetMaxIterations(10000);  // for GSL 
  min->SetTolerance(0.0001);
  min->SetPrintLevel(1);
  
  
  ROOT::Math::Functor ft(&efit,IVEC+nVec);     
  min->SetFunction(ft);
  
  
  //Now set the variables
  min->SetLimitedVariable(THETA,   "Theta",   par[THETA],      par[THETA]/100.0,  0.95*par[THETA], 1.05*par[THETA]);
  min->SetLimitedVariable(SIGMA,   "Sigma",   2.5*par[SIGMA],  par[SIGMA]/100.0,  par[SIGMA],  5.0*par[SIGMA]);
  min->SetLimitedVariable(THETAR,  "Thetar",  par[THETAR],     par[THETAR]/100.0, 0.95*par[THETAR], 1.05*par[THETAR]);
  min->SetLimitedVariable(SIGMAR,  "Sigmar",  par[SIGMAR], par[SIGMAR]/100.0, 0.1*par[SIGMAR], 20*par[SIGMAR]);
  //    min->SetFixedVariable(SIGMAR,  "Sigmar",  0.01*par[SIGMAR]);
  //    min->SetLimitedVariable(POWER,  "Power",  par[POWER], par[POWER]/100.0, 0.1*par[POWER], 20*par[POWER]);
  min->SetFixedVariable(E0MEV,     "E0MeV",   par[E0MEV]);  //no of vectors
  min->SetFixedVariable(NVEC,      "Nvec",    par[NVEC]);  //no of vectors

  for(Int_t m=0;m<nVec;m++){
    sprintf(name,"Vec0%d%d", VECTORS[m],VECTORS[m]);
    //      min->SetFixedVariable(n+IVEC, name, 2*par[n+IVEC]); 
    min->SetLimitedVariable(m+IVEC, name, par[m+IVEC], par[m+IVEC]/100.0, 0.0, 10*par[m+IVEC]); 
  }
  
  verbose=1;             //make it show the fit as it's improving
  bestChisq=100000.00;   //set this high for starters
  
  min->Minimize();
  
  //    if(bestChisq>1.02) continue;
  
  
  enhFromParams(bestPar);
  
  histE->GetXaxis()->SetRange(70,110);
    
  gausFit->SetRange(histE->GetBinCenter(histE->GetMaximumBin()),histE->GetBinCenter(histE->GetMaximumBin())+50.0);
  gausFit->SetParameter(1,histE->GetBinCenter(histE->GetMaximumBin()));
  gausFit->SetParameter(2,10.0);
  gausFit->SetParameter(3,1.0);
  histE->Fit(gausFit,"rN");
  
  maxBin = histE->GetMaximumBin();
  
  lowmean=0.0;

    
  histE->GetXaxis()->SetRange();
  histD->GetXaxis()->SetRange();
  histP->GetXaxis()->SetRange();
  
  histD->GetXaxis()->SetRange();
  
  enhHist->Reset();

  for(UInt_t n=1;n<=nBins-1;n++){
    

    polHist->SetBinContent(n,histP->GetBinContent(n));
    enhFit->SetBinContent(n,histE->GetBinContent(n));
    enhHist->SetBinContent(n,histD->GetBinContent(n));
    polHist->SetBinError(n,histP->GetBinError(n));
    enhFit->SetBinError(n,histE->GetBinError(n));
    enhHist->SetBinError(n,histD->GetBinError(n));
    
  }

  TCanvas* can = new TCanvas("Canvas", "Canvas",0,0,1500,950);
  histD->Draw();
  histE->Draw("same");
  can->Write();

}
  
void parFromHuman(Double_t beamMeV, Double_t edgeMeV, Double_t spreadMeV, Double_t colliDist_m, Double_t colliRad_mm, Int_t nVec, Double_t *par){

  //takes some physical quantities and makes them into parameters, then calls the 
  //enhFromParams function.
  
  
  //  Double_t par[10];                                                           //array of parameters
  Int_t g = 2;                                                                //variables used in CLAS note
  Double_t E0 = beamMeV;
  Double_t Eg = edgeMeV;
  
  
  par[THETA]  = k/(g*E0*E0*((1/Eg)-(1/E0)));                                  //theta from edge and beam energy
  par[SIGMA]  = (par[THETA]-(k/(g*E0*E0*((1/(Eg-spreadMeV))-(1/E0)))))/3.0;   //spread in theta from spread in edge 
  par[THETAR] = E0*0.001*colliRad_mm/colliDist_m;                         //cut from collimator //ORIGINAL
  //  par[THETAR] = E0*0.001*5.0*colliRad_mm/colliDist_m;                         //cut from collimator
  //par[THETAR] = E0*0.0005*5.0*colliRad_mm/colliDist_m;                         //cut from collimator
  par[SIGMAR] = par[THETAR]*par[SIGMA]/par[THETA];                            //smear in above same fractional sigma as above //ORIGINAL
  //par[SIGMAR] = 0.5*par[THETAR]*par[SIGMA]/par[THETA];                            //smear in above same fractional sigma as above
  //  par[POWER]  = -0.5;
  par[E0MEV]  = E0;                                                           //beam energy
  par[NVEC]   = (Double_t)nVec;                                                         //no of harmonics

  for(int v=0;v<par[NVEC];v++){                                               //give the vectors intensities
    par[IVEC+v] = 2.0/(Double_t)VECTORS[v];                                   //tailing off as 1/VECTORS[v]
    //cout << IVEC+v << "  v   " << par[IVEC+v] << endl; 
  }

  //enhFromParams(par);

}  


//The main customized fitting function which gets called by MINUIT
Double_t efit(const Double_t *parms){
  
  Double_t chisq = 1.0;
  Double_t delta;
  Double_t b1,b2;
  Double_t err;
  Double_t *par = (Double_t*)parms;

  histE->Reset("ICE"); //reset the histogram

  //call the function to make the enhancement and polarization
  enhFromParams(par);

  chisq = 1.0;
  //loop over all the required bins in the histogram to work out a chisq
  for(int n=fitMinBin;n<=fitMaxBin;n++){
    b1=histE->GetBinContent(n);
    b2=histD->GetBinContent(n);
    //    err=1;//histE->GetBinError(n)/histD->GetBinError(n);
    err=histE->GetBinError(n);
    delta=(b1-b2)/err;
    chisq+=(delta*delta)/b1;
    //note - not a proper chisq because its an enhancement

  }

  fprintf(stderr,"Chisq: \t%6.2f\t\r",chisq);

  if(chisq<bestChisq){
    bestChisq=chisq;
    for(Int_t n=0;n<10;n++){
      bestPar[n]=par[n];
    }
    if(verbose){	                   //if verbose, draw every 10th one the canvas to see how it's going
      if(10%(counter++)){

	genCanvas->cd(1);
	histD->SetLineColor(4);
	histD->Draw();
	histD->SetMinimum(0.0);
	histD->SetMaximum(6.0);
	genCanvas->cd(1);
	histE->Draw("HIST same");
	
	genCanvas->cd(2);
	histP->Draw("HIST");
	histP->SetMinimum(0);
	histP->SetMaximum(1);
	
	genCanvas->Draw();   
	
	genCanvas->Update();
	gSystem->ProcessEvents();
	counter=1;
      }
    }
  }
  return chisq;
  
}

void enhFromParams(Double_t *par){
  //make an enhancement and corresponding polarization from some the parameters as defined in the CLAS note.
  //this function is can be called stand alone, but will also ba called many times from the fitting function

  Double_t xd[10];
  Double_t xc[10];
  Double_t Q[10];
  Double_t cohContrib;
  Double_t cohTotal;
  Double_t phiTotal;
  Double_t etotal;
  Double_t ptotal;
  Double_t x=0.0;
  Int_t    g=0;
  Double_t weight=0.0;
  Double_t weightError=0.0;
  Double_t weightSum=0.0;
  Double_t polSum=0.0;
  Double_t weightSumError=0.0;
  Double_t polSumError=0.0;
  Double_t phi,chi,cd;
  Double_t amo;
  Int_t jbin=0;
 
  //loop over sigma
  // for(int p=0;p<10;p++){
  //  cout << p << ": " << par[p] << ", ";
  //}
  //cout << endl;

  // if needed, make some hists
//   if(!histE){
//     histE        = new TH1F("Enhancement", "Enhancement",  1000, 0, par[E0MEV]);
//     histP        = new TH1F("Polarization", "Polarization",1000, 0, par[E0MEV]);
//     histE->SetMinimum(0);
//     histP->SetMinimum(0);
//     histP->SetMaximum(1);
//   }    
  if(!thetaPol){
    weightHist   = new TH1F("weightHist",  "weightHist", THETASTEPS+1, 0, THETASTEPS+1 );
    thetaWeight  = new TH2F("thetaWeight", "thetaWeight",histE->GetNbinsX(), histE->GetXaxis()->GetXmin(), histE->GetXaxis()->GetXmax(), THETASTEPS+1,0, THETASTEPS+1);
    thetaPol     = new TH2F("thetaPol",    "thetaPol",   histE->GetNbinsX(), histE->GetXaxis()->GetXmin(), histE->GetXaxis()->GetXmax(), THETASTEPS+1,0, THETASTEPS+1);
    thetaItot    = new TH2F("thetaItot",   "thetaItot",  histE->GetNbinsX(), histE->GetXaxis()->GetXmin(), histE->GetXaxis()->GetXmax(), THETASTEPS+1,0, THETASTEPS+1);
//     thetaWeight  = new TH2F("thetaWeight", "thetaWeight",histE->GetNbinsX(), histE->GetXaxis()->GetXbins()->GetArray(), THETASTEPS+1,0, THETASTEPS+1);
//     thetaPol     = new TH2F("thetaPol",    "thetaPol",   histE->GetNbinsX(), histE->GetXaxis()->GetXbins()->GetArray(), THETASTEPS+1,0, THETASTEPS+1);
//     thetaItot    = new TH2F("thetaItot",   "thetaItot",  histE->GetNbinsX(), histE->GetXaxis()->GetXbins()->GetArray(), THETASTEPS+1,0, THETASTEPS+1);
    weightHist ->Sumw2();
    thetaWeight->Sumw2();
    thetaPol   ->Sumw2();
    thetaItot  ->Sumw2();
  }

  //reset them all for fresh filling
  histE->Reset("ICE");
  histP->Reset("ICE");
  thetaPol->Reset("ICE");
  thetaItot->Reset("ICE");
  weightHist->Reset("ICE");
  thetaWeight->Reset("ICE");

  for(Double_t j=par[THETA]-3.0*par[SIGMA];j<=par[THETA]+3.001*par[SIGMA];j+=(6.0*par[SIGMA])/THETASTEPS){
    
    weight=TMath::Gaus(j,par[THETA],par[SIGMA]);   //get the weight from the gaussian
    //cout << weight << endl;
    weightSum+=weight;                             //add to sum      
    
    //find the discontinuity for each vector
    for(int v=0;v<par[NVEC];v++){
      g=VECTORS[v];
      xd[v]=1.0/((k/(g*par[E0MEV]*j))+1.0);
      Q[v]=(1.0-xd[v])/xd[v];
      xc[v]=xd[v]/(1+((par[THETAR]*par[THETAR])*(1-xd[v])));
    }

    //loop over all bins in the histogram
    for(int bin=1;bin<=histE->GetNbinsX();bin++){
      x=histE->GetBinCenter(bin)/par[E0MEV];            //find the value of the bin
      //amo=1/x;                                    //assume amo = inc = 1/x over region of interest
      //      amo=TMath::Power(x,par[POWER]);                                    //assume amo = inc = 1/x over region of interest
      //      amo=TMath::Power(x,-0.5);                                    //assume amo = inc = 1/x over region of interest
      amo=TMath::Power(x,-1);                                    //assume amo = inc = 1/x over region of interest
      
      cohTotal=0.0;
      phiTotal=0.0;
      
      //loop over all the vectors
      for(int v=0;v<par[NVEC];v++){
	if(x>xd[v]) continue;           //only do up to x_dg
	 
	//work out chi and phi
	phi=(2*Q[v]*Q[v]*x*x)/((1-x)*(1+((1-x)*(1-x))-((4*Q[v]*Q[v]*x*x/(1-x))*(((1-x)/(Q[v]*x))-1))));
	//	chi=((Q[v]*Q[v])/(1-x))*(1+((1-x)*(1-x))-((4*Q[v]*Q[v]*x*x/(1-x))*(((1-x)/(Q[v]*x))-1)));
	chi=((Q[v]*Q[v]*x)/(1-x))*(1+((1-x)*(1-x))-((4*Q[v]*Q[v]*x*x/(1-x))*(((1-x)/(Q[v]*x))-1))); //RETURN
	//	cout << j  << "  " << chi << endl;
	cd=0.5*(1+TMath::Erf((x-xc[v])/(TMath::Sqrt(2)*par[SIGMAR])));

	//get coherent contrib for the vector
	cohContrib=cd*par[IVEC+v]*chi;

	//add to the total and update the phi total
	cohTotal+=cohContrib;
	phiTotal+=cohContrib*phi;
	
      }
      if(cohTotal>0.0) {
	phiTotal/=cohTotal;   //divide by the cohTotal to get the weighted dmean phi 
      }

      //enhancement = coherent total + inc (or amo).
      etotal=1+(cohTotal)/(amo);
      //and pol like this
      ptotal=phiTotal*cohTotal;

      //add the weighted contribution to the enhancement
      histE->Fill(x*par[E0MEV],weight*etotal);
//       histE->Fill(x*par[E0MEV],cohTotal);
//       histE->Draw();
      //histE->Fill(x*par[E0MEV],etotal);

      //keep the pol for this x,theta coord
      //     thetaPol->Fill(bin,jbin,ptotal);
      thetaPol->Fill(x*par[E0MEV],jbin,ptotal);
      //      cout << thetaPol->GetXaxis()->FindBin(x*par[E0MEV]) << " " << jbin << " " << thetaPol->GetBinContent(thetaPol->GetXaxis()->FindBin(x*par[E0MEV]),jbin) << endl;

      //keep the total intensity for this x,theta coord
      thetaItot->Fill(x*par[E0MEV],jbin,cohTotal+amo);
      // cout << x << " " << par[E0MEV] << " " << jbin << " " << ptotal << " " << cohTotal << " " << amo << endl;

    }
    
    //save the weight for this theta point
    weightHist->Fill(jbin,weight);
    //    cout << jbin << " " << weight << endl;
    jbin++;

  }
  //normalize the sum of the weighted enhancements
  histE->Scale(1.0/weightSum);
  
  
  //loop over each x bin, adding the weighted contribs from each theta pos
  for(int bin=1; bin<=histE->GetNbinsX(); bin++){
    weightSum=0.0;
    polSum=0.0;
    
    for(int jb=1;jb<=weightHist->GetNbinsX();jb++){
      weight=weightHist->GetBinContent(jb);
      weightError=weightHist->GetBinError(jb);

      polSum+=thetaPol->GetBinContent(bin,jb)*weight;
      weightSum+=thetaItot->GetBinContent(bin,jb)*weight;

      polSumError+=thetaPol->GetBinError(bin,jb)*weightError;
      weightSumError+=thetaItot->GetBinError(bin,jb)*weightError;
    }

    ///    cout << weightSum << " " << weightSumError << endl;

      if(weightSum!=0)   polSum/=weightSum;
      if(weightSumError!=0) polSumError/=weightSumError;
    //    histP->Fill(histP->GetBinCenter(bin),polSum);

     //  cout << bin << " " << polSum << endl;
//       cout << polSumError << endl;

    histP->SetBinContent(bin,polSum);
    histP->SetBinError(bin,polSumError);
  } 
}

//------------------------------------------
