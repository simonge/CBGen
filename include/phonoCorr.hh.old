//
// phonoCorr.C - computes the coherent bremsstrahlung energy and
//                polarization spectrum with phonon corrections.
//
// author: richard.t.jones at uconn.edu
// version: march 25, 2017

//#define TEST_SAMPLE_DQ2 1

#include <iostream>
#include <math.h>

#include <TH1D.h>
#include <TH2D.h>
#include <TAxis.h>
#include <TFile.h>
#include <TTree.h>
#include <TROOT.h>
#include <TRandom3.h>

#include "Complex.h"
#include "TPhoton.h"
#include "TLepton.h"
#include "TCrossSection.h"
#include "TThreeVectorReal.h"
#include "TFourVectorReal.h"
#include "TLorentzBoost.h"
#include "constants.h"

#include "AdaptiveSampler.cc"

#ifndef DEFINE_SQR_ON_STANDARD_TYPES
#define DEFINE_SQR_ON_STANDARD_TYPES
inline unsigned int sqr(unsigned int x) { return x*x; }
inline Int_t sqr(Int_t x) { return x*x; }
inline Float_t sqr(Float_t x) { return x*x; }
inline Double_t sqr(Double_t x) { return x*x; }
inline LDouble_t sqr(LDouble_t x) { return x*x; }
inline Complex_t sqr(Complex_t x) { return x*x; }
#endif

#ifndef STANDARD_VECTOR_CONSTANTS
#define STANDARD_VECTOR_CONSTANTS
const TThreeVectorReal zeroVector(0,0,0);
const TThreeVectorReal posXhat(1,0,0);
const TThreeVectorReal negXhat(-1,0,0);
const TThreeVectorReal posYhat(0,1,0);
const TThreeVectorReal negYhat(0,-1,0);
const TThreeVectorReal posZhat(0,0,1);
const TThreeVectorReal negZhat(0,0,-1);
#endif

// parameters for the beamline
double Ebeam      = 12.;     // GeV
double radcoldist = 76.; // m
double pbeam      = sqrt(sqr(Ebeam) - sqr(mElectron));

// physical parameters for the target crystal
const double Eedge      = 9.;      // GeV
const double qtotal_220 = 9.8e-6; // GeV
const double qlong_220  = Eedge / (Ebeam - Eedge) * sqr(mElectron) / (2 * Ebeam);
const double aLattice   = 3.567e-10;   // m
const double hbarc      = 1.97327e-16;    // GeV.m
const double kBoltzmann = 8.617e-14; // GeV/K
const double TDebye     = 2200;          // K
double kT               = kBoltzmann * 300;        // GeV

const double Ncell  = 8;
const double Vcell  = 45.5e-30;       // m^3
const double Matom  = 12 * 0.932;     // GeV/c^2
const double ThetaD = 8.617e-14 * 2200; // GeV
const double Qmax   = 2 * M_PI * hbarc * pow(3 / (4 * M_PI) * Ncell / Vcell, 1/3.); // GeV/c
const double log_10 = log(10.);

double L1dual0 = 0;

TH2D *hDQ2q_high_q2 = 0;
TH2D *hDQ2_low_q2 = 0;

// fRandom MUST be initialized before use, but I find that
// if I call the constructor here at file scope then sometimes
// processes started near to the same time on the same machine
// end up generating the exact same sequence. Watch out for that!
// One way to reduce the likelihood of it happening is to insert
// a wait of a few seconds between the startup of each process.

void unif01(int n, double *u) { fRandom->RndmArray(n,u); }

TH1D *hL1dual = 0;
TH1D *hRDdual = 0;

double nBoseEinstein(double x)

double L1dual(double R, int ndiv=1000)

TH1D *L1dual_hist(int nbins, double Rmax, double Rmin=1e-12, int ndiv=1000)

void make_hL1dual(double R, int nbins=1000)

void set_temperature(double T) { kT = kBoltzmann * T;}

double RDdual(double q2, double R)

TH1D *RDdual_hist(double q2, double Rmax, double Rmin=1e-12, int ndiv=1000)

void make_hRDdual(double q2, double R, int ndiv=1000)

TH1D *htest_hist(TH1D *clone)

double DQ2(double q2, double Q, int ndiv=1000)

TH1D *DQ2_hist(double q2, double Qmax, int nbins=1000)

double MeanNphonons(double q2)

double DQ2_gauss(double q2, double Q)

void make_hDQ2_gauss(double q2, double Qmax, int nbins=1000)

double sample_hkl(int hkl[3], const double u[3])

int sample_hkl_test(int nsamples, TString rootfile)

void prepare_sampling()

int gentree(int nsamples, TString rootfile)
